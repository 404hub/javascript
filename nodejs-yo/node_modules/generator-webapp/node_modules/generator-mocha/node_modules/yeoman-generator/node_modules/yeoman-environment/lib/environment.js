'use strict';
var util = require('util');
var path = require('path');
var events = require('events');
var chalk = require('chalk');
var _ = require('lodash');
var GroupedQueue = require('grouped-queue');
var escapeStrRe = require('escape-string-regexp');
var untildify = require('untildify');
var memFs = require('mem-fs');
var debug = require('debug')('generators:environment');
var Store = require('./store');
var resolver = require('./resolver');
var TerminalAdapter = require('./adapter');

/**
 * `Environment` object is responsible of handling the lifecyle and bootstrap
 * of generators in a specific environment (your app).
 *
 * It provides a high-level API to create and run generators, as well as further
 * tuning where and how a generator is resolved.
 *
 * An environment is created using a list of `arguments` and a Hash of
 * `options`. Usually, this is the list of arguments you get back from your CLI
 * options parser.
 *
 * An optional adapter can be passed to provide interaction in non-CLI environment
 * (e.g. IDE plugins), otherwise a `TerminalAdapter` is instantiated by default
 *
 * @constructor
 * @mixes env/resolver
 * @param {String|Array} args
 * @param {Object} opts
 * @param {TerminalAdapter} [adaper] - A TerminalAdapter instance or another object
 *                                     implementing this adapter interface. This is how
 *                                     you'd interface Yeoman with a GUI or an editor.
 */

var Environment = module.exports = function Environment(args, opts, adapter) {
  events.EventEmitter.call(this);

  args = args || [];
  this.arguments = Array.isArray(args) ? args : args.split(' ');
  this.options = opts || {};
  this.adapter = adapter || new TerminalAdapter();
  this.cwd = this.options.cwd || process.cwd();
  this.store = new Store();

  this.runLoop = new GroupedQueue(Environment.queues);
  this.sharedFs = memFs.create();

  // Each composed generator might set listeners on these shared resources. Let's make sure
  // Node won't complain about event listeners leaks.
  this.runLoop.setMaxListeners(0);
  this.sharedFs.setMaxListeners(0);

  this.lookups = ['.', 'generators', 'lib/generators'];
  this.aliases = [];

  this.alias(/^([^:]+)$/, '$1:app');
};

util.inherits(Environment, events.EventEmitter);
_.extend(Environment.prototype, resolver);

Environment.queues = [
  'initializing',
  'prompting',
  'configuring',
  'default',
  'writing',
  'conflicts',
  'install',
  'end'
];

/**
 * Error handler taking `err` instance of Error.
 *
 * The `error` event is emitted with the error object, if no `error` listener
 * is registered, then we throw the error.
 *
 * @param  {Object} err
 * @return {Error}  err
 */

Environment.prototype.error = function error(err) {
  err = err instanceof Error ? err : new Error(err);

  if (!this.emit('error', err)) {
    throw err;
  }

  return err;
};

/**
 * Outputs the general help and usage. Optionally, if generators have been
 * registered, the list of available generators is also displayed.
 *
 * @param {String} name
 */

Env